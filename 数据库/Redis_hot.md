### 1）Redis为什么使用单进程单线程方式也这么快

Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。

Redis快的主要原因是：

1. 完全基于内存
2. 数据结构简单，对数据操作也简单
3. 使用多路 I/O 复用模型

多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。


和Memcached不同，Redis并没有直接使用Libevent，而是自己完成了一个非常轻量级的对select、epoll、evport、kqueue这些通用的接口的实现。在不同的系统调用选用适合的接口，linux下默认是epoll。因为Libevent比较重更通用代码量也就很庞大，拥有很多Redis用不上的功能，Redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。


#### 单进程单线程好处
- 代码更清晰，处理逻辑更简单
- 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 不存在多进程或者多线程导致的切换而消耗CPU

#### 单进程单线程弊端
无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；

#### 其他一些优秀的开源软件采用的模型

- 多进程单线程模型：Nginx
- 单进程多线程模型：Memcached

### 2）五种类型数据类型

字符串、列表、散列表，集合、有序集合

### 3）内存中数据持久化

使用复制来扩展读性能：复制到多台服务器、提高读性能和可用性

使用分区来扩展写性能【hash一致性算法】：当数据量大的时候,把数据分散存入多个数据库中,减少单节点的连接压力

特点

- 完全基于内存
- 数据结构简单，对数据操作也简单
- 使用多路 I/O 复用模型

### 4）Redis 适用场景

1. 缓存 将热点数据放到内存中
2. 消息队列 List 类型是双向链表，很适合用于消息队列
3. 计数器 快速、频繁读写操作；string的单线性自增减 ++ --
4. 共同好友关系 set 交集运算，很容易就可以知道用户的共同好友
5. 排名 zset有序集合

### 5）持久化

快照持久化

将某个时间点的所有数据都存放到硬盘上

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本

缺点：故障可能丢失最后一次创建快照之后的数据；如果数据量很大，保存快照的时间也会很长。

AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾

- always： 每个写命令都同步，严重减低服务器的性能；
- everysec ：每秒同步一次，比较合适，保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no ：让操作系统来决定何时同步，不能给性能带来提升，且会增加奔溃时数据丢失量
 

随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，操作系统决定何时写

用户可以调用 file.flush() 方法请求尽快将缓冲区存储的数据同步到硬盘

redis主从复制 分布式数据同步方式

slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器

从服务器连接主服务器的过程


- 主服务器创建快照文件，发送给从服务器。同时记录其间执行的写命令，发送完毕后，开始向从服务器发送写命令；
- 从服务器丢弃所有旧数据，载入主服务器的快照文件，然后开始接受主服务器发来的写命令；
- 主服务器每执行一次写命令，就向从服务器发送相同的写命令

主从链 创建一个中间层来分担主服务器的复制工作

- 随着负载不断上升，主服务器可能无法很快地更新所有从服务器
- 重新连接和重新同步从服务器将导致系统超载
- 中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器


### 6）redis 主服务器 故障 处理

当主服务器出现故障时，Redis 常用的做法是新开一台服务器作为主服务器，具体步骤如下：假设 A 为主服务器，B 为从服务器，当 A 出现故障时，让 B 生成一个快照文件，将快照文件发送给 C，并让 C 恢复快照文件的数据。最后，让 B 成为 C 的从服务器。

### 7）分片 集群 读并发

数据划分为多个部分，可以将数据存储到多台机器里，作用：负载均衡、线性级别的性能提升

### 8）分片方式：

客户端代码分片

- Redis Sharding，对Redis数据的key进行hash，相同的key到相同的节点上
- 一致性哈希算法
- 代理服务器分片 轮询round-bin

### 9）redis与数据库的同步 数据一致

- 一致性要求高场景，实时同步方案，即查询redis，若查询不到再从DB查询，保存到redis；

- 更新redis时，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)，再用ZINCRBY增量修正redis数据

- 并发程度高的，采用异步队列的方式，采用kafka等消息中间件处理消息生产和消费

- 阿里的同步工具canal，实现方式是模拟mysql slave和master的同步机制，监控DB bitlog的日志更新来触发redis的更新，解放程序员双手，减少工作量

- 利用mysql触发器的API进行编程,c/c++语言实现，学习成本高。


### 10）热数据与Mysql的同步编码实现 数据库上锁

热点数据（经常会被查询，但是不经常被修改或者删除的数据），首选是使用redis缓存

用spring的AOP来构建redis缓存的自动生产和清除，过程如下：

- Select 数据库前查询redis，有的话使用redis数据，放弃select 数据库，没有的话，select 数据库，然后将数据插入redis
- update或者delete 数据库数据
    - 高并发的情况下：先对数据库加锁，再删除redis
    - 查询redis是否存在该数据，若存在则先对数据库加行锁，再删除redis，再update或者delete数据库中数据
- update或者delete redis，先更新数据库，再将redis内容设置为过期(建议不要去更新缓存内容，直接设置缓存过期)
 

出错场景：update先删掉了redis中的该数据，这时另一个线程执行查询，发现redis中没有，瞬间执行了查询SQL，并且插入到redis

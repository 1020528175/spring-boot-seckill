### 1)1Redis为什么使用单进程单线程方式也这么快

Redis采用的是基于内存的采用的是单进程单线程模型的KV数据库，由C语言编写。官方提供的数据是可以达到100000+的qps。这个数据不比采用单进程多线程的同样基于内存的KV数据库Memcached差。

Redis快的主要原因是：

1. 完全基于内存
2. 数据结构简单，对数据操作也简单
3. 使用多路 I/O 复用模型

多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。


和Memcached不同，Redis并没有直接使用Libevent，而是自己完成了一个非常轻量级的对select、epoll、evport、kqueue这些通用的接口的实现。在不同的系统调用选用适合的接口，linux下默认是epoll。因为Libevent比较重更通用代码量也就很庞大，拥有很多Redis用不上的功能，Redis为了追求“轻巧”并且去除依赖，就选择自己去封装了一套。


#### 单进程单线程好处
- 代码更清晰，处理逻辑更简单
- 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 不存在多进程或者多线程导致的切换而消耗CPU

#### 单进程单线程弊端
无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；

#### 其他一些优秀的开源软件采用的模型

- 多进程单线程模型：Nginx
- 单进程多线程模型：Memcached

### 2)五种类型数据类型

字符串、列表、散列表，集合、有序集合

### 3)内存中数据持久化

使用复制来扩展读性能：复制到多台服务器、提高读性能和可用性

使用分区来扩展写性能【hash一致性算法】：当数据量大的时候,把数据分散存入多个数据库中,减少单节点的连接压力

特点

- 完全基于内存
- 数据结构简单，对数据操作也简单
- 使用多路 I/O 复用模型

### 4)Redis 适用场景

1. 缓存 将热点数据放到内存中
2. 消息队列 List 类型是双向链表，很适合用于消息队列
3. 计数器 快速、频繁读写操作；string的单线性自增减 ++ --
4. 共同好友关系 set 交集运算，很容易就可以知道用户的共同好友
5. 排名 zset有序集合

### 5)持久化

快照持久化

将某个时间点的所有数据都存放到硬盘上

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本

缺点：故障可能丢失最后一次创建快照之后的数据；如果数据量很大，保存快照的时间也会很长。

AOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾

- always： 每个写命令都同步，严重减低服务器的性能；
- everysec ：每秒同步一次，比较合适，保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no ：让操作系统来决定何时同步，不能给性能带来提升，且会增加奔溃时数据丢失量
 

随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，操作系统决定何时写

用户可以调用 file.flush() 方法请求尽快将缓冲区存储的数据同步到硬盘

redis主从复制 分布式数据同步方式

slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器

从服务器连接主服务器的过程


- 主服务器创建快照文件，发送给从服务器。同时记录其间执行的写命令，发送完毕后，开始向从服务器发送写命令；
- 从服务器丢弃所有旧数据，载入主服务器的快照文件，然后开始接受主服务器发来的写命令；
- 主服务器每执行一次写命令，就向从服务器发送相同的写命令

主从链 创建一个中间层来分担主服务器的复制工作

- 随着负载不断上升，主服务器可能无法很快地更新所有从服务器
- 重新连接和重新同步从服务器将导致系统超载
- 中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器
